import { computed, unref, watch, ref, customRef, isVue3, isRef, effectScope, getCurrentScope, onScopeDispose, shallowRef, watchSyncEffect, readonly, reactive, toRef, isVue2, toRefs as toRefs$1, getCurrentInstance, onBeforeUnmount, onMounted, nextTick, onUnmounted } from 'vue-demi';

/**
 * `AND` conditions for refs.
 *
 * @see https://vueuse.org/and
 */
function and(...args) {
    return computed(() => args.every(i => unref(i)));
}

/**
 * Two-way refs synchronization.
 *
 * @param a
 * @param b
 */
function biSyncRef(a, b) {
    const flush = 'sync';
    const stop1 = watch(a, (newValue) => {
        b.value = newValue;
    }, {
        flush,
        immediate: true,
    });
    const stop2 = watch(b, (newValue) => {
        a.value = newValue;
    }, {
        flush,
        immediate: true,
    });
    return () => {
        stop1();
        stop2();
    };
}

/**
 * Explicitly define the deps of computed.
 *
 * @param source
 * @param fn
 */
function controlledComputed(source, fn) {
    let v = undefined;
    let track;
    let trigger;
    const dirty = ref(true);
    watch(source, () => {
        dirty.value = true;
        trigger();
    }, { flush: 'sync' });
    return customRef((_track, _trigger) => {
        track = _track;
        trigger = _trigger;
        return {
            get() {
                if (dirty.value) {
                    v = fn();
                    dirty.value = false;
                }
                track();
                return v;
            },
            set() { },
        };
    });
}

function __onlyVue3(name = 'this function') {
    if (isVue3)
        return;
    throw new Error(`[VueUse] ${name} is only works on Vue 3.`);
}

// implementation
function extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {
    __onlyVue3();
    for (const [key, value] of Object.entries(extend)) {
        if (key === 'value')
            continue;
        if (isRef(value) && unwrap) {
            Object.defineProperty(ref, key, {
                get() {
                    return value.value;
                },
                set(v) {
                    value.value = v;
                },
                enumerable,
            });
        }
        else {
            Object.defineProperty(ref, key, { value, enumerable });
        }
    }
    return ref;
}

/**
 * Explicitly define the deps of computed.
 *
 * @param source
 * @param fn
 */
function controlledRef(initial, options = {}) {
    let source = initial;
    let track;
    let trigger;
    const ref = customRef((_track, _trigger) => {
        track = _track;
        trigger = _trigger;
        return {
            get() {
                return get();
            },
            set(v) {
                set(v);
            },
        };
    });
    function get(tracking = true) {
        if (tracking)
            track();
        return source;
    }
    function set(value, triggering = true) {
        var _a, _b;
        if (value === source)
            return;
        const old = source;
        if (((_a = options.onBeforeChange) === null || _a === void 0 ? void 0 : _a.call(options, value, old)) === false)
            return; // dismissed
        source = value;
        (_b = options.onChanged) === null || _b === void 0 ? void 0 : _b.call(options, value, old);
        if (triggering)
            trigger();
    }
    /**
     * Get the value without tracked in the reactivity system
     */
    const untrackedGet = () => get(false);
    /**
     * Set the value without triggering the reactivity system
     */
    const silentSet = (v) => set(v, false);
    /**
     * Get the value without tracked in the reactivity system.
     *
     * Alias for `untrackedGet()`
     */
    const peek = () => get(false);
    /**
     * Set the value without triggering the reactivity system
     *
     * Alias for `silentSet(v)`
     */
    const lay = (v) => set(v, false);
    return extendRef(ref, {
        get,
        set,
        untrackedGet,
        silentSet,
        peek,
        lay,
    }, { enumerable: true });
}

/**
 * The source code for this function was inspired by vue-apollo's `useEventHook` util
 * https://github.com/vuejs/vue-apollo/blob/v4/packages/vue-apollo-composable/src/util/useEventHook.ts
 */
/**
 * Utility for creating event hooks
 *
 * @see https://vueuse.org/createEventHook
 */
function createEventHook() {
    const fns = [];
    const off = (fn) => {
        const index = fns.indexOf(fn);
        if (index !== -1)
            fns.splice(index, 1);
    };
    const on = (fn) => {
        fns.push(fn);
        return {
            off: () => off(fn),
        };
    };
    const trigger = (param) => {
        fns.forEach(fn => fn(param));
    };
    return {
        on,
        off,
        trigger,
    };
}

/**
 * Keep states in the global scope to be reusable across Vue instances.
 *
 * @see https://vueuse.org/createGlobalState
 * @param stateFactory A factory function to create the state
 */
function createGlobalState(stateFactory) {
    let initialized = false;
    let state;
    const scope = effectScope(true);
    return () => {
        if (!initialized) {
            state = scope.run(stateFactory);
            initialized = true;
        }
        return state;
    };
}

/**
 * Call onScopeDispose() if it's inside a effect scope lifecycle, if not, do nothing
 *
 * @param fn
 */
function tryOnScopeDispose(fn) {
    if (getCurrentScope()) {
        onScopeDispose(fn);
        return true;
    }
    return false;
}

/**
 * Make a composable function usable with multiple Vue instances.
 *
 * @see https://vueuse.org/createSharedComposable
 */
function createSharedComposable(composable) {
    let subscribers = 0;
    let state;
    let scope;
    const dispose = () => {
        subscribers -= 1;
        if (scope && subscribers <= 0) {
            scope.stop();
            state = undefined;
            scope = undefined;
        }
    };
    return ((...args) => {
        subscribers += 1;
        if (!state) {
            scope = effectScope(true);
            state = scope.run(() => composable(...args));
        }
        tryOnScopeDispose(dispose);
        return state;
    });
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

const isClient = typeof window !== 'undefined';
const isDef = (val) => typeof val !== 'undefined';
const assert = (condition, ...infos) => {
    // eslint-disable-next-line no-console
    if (!condition)
        console.warn(...infos);
};
const toString = Object.prototype.toString;
const isBoolean = (val) => typeof val === 'boolean';
const isFunction = (val) => typeof val === 'function';
const isNumber = (val) => typeof val === 'number';
const isString = (val) => typeof val === 'string';
const isObject = (val) => toString.call(val) === '[object Object]';
const isWindow = (val) => typeof window !== 'undefined' && toString.call(val) === '[object Window]';
const now = () => Date.now();
const timestamp = () => +Date.now();
const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
const noop = () => { };
const rand = (min, max) => {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
};

/**
 * @internal
 */
function createFilterWrapper(filter, fn) {
    function wrapper(...args) {
        filter(() => fn.apply(this, args), { fn, thisArg: this, args });
    }
    return wrapper;
}
const bypassFilter = (invoke) => {
    return invoke();
};
/**
 * Create an EventFilter that debounce the events
 *
 * @param ms
 */
function debounceFilter(ms) {
    let timer;
    const filter = (invoke) => {
        const duration = unref(ms);
        if (timer)
            clearTimeout(timer);
        if (duration <= 0)
            return invoke();
        timer = setTimeout(invoke, duration);
    };
    return filter;
}
/**
 * Create an EventFilter that throttle the events
 *
 * @param ms
 * @param [trailing=true]
 */
function throttleFilter(ms, trailing = true) {
    let lastExec = 0;
    let timer;
    const clear = () => {
        if (timer) {
            clearTimeout(timer);
            timer = undefined;
        }
    };
    const filter = (invoke) => {
        const duration = unref(ms);
        const elapsed = Date.now() - lastExec;
        clear();
        if (duration <= 0) {
            lastExec = Date.now();
            return invoke();
        }
        if (elapsed > duration) {
            lastExec = Date.now();
            invoke();
        }
        else if (trailing) {
            timer = setTimeout(() => {
                lastExec = Date.now();
                clear();
                invoke();
            }, duration);
        }
    };
    return filter;
}
/**
 * EventFilter that gives extra controls to pause and resume the filter
 *
 * @param extendFilter  Extra filter to apply when the PauseableFilter is active, default to none
 *
 */
function pausableFilter(extendFilter = bypassFilter) {
    const isActive = ref(true);
    function pause() {
        isActive.value = false;
    }
    function resume() {
        isActive.value = true;
    }
    const eventFilter = (...args) => {
        if (isActive.value)
            extendFilter(...args);
    };
    return { isActive, pause, resume, eventFilter };
}

function promiseTimeout(ms, throwOnTimeout = false, reason = 'Timeout') {
    return new Promise((resolve, reject) => {
        if (throwOnTimeout)
            setTimeout(() => reject(reason), ms);
        else
            setTimeout(resolve, ms);
    });
}
function identity(arg) {
    return arg;
}
/**
 * Create singleton promise function
 *
 * @example
 * ```
 * const promise = createSingletonPromise(async () => { ... })
 *
 * await promise()
 * await promise() // all of them will be bind to a single promise instance
 * await promise() // and be resolved together
 * ```
 */
function createSingletonPromise(fn) {
    let _promise;
    function wrapper() {
        if (!_promise)
            _promise = fn();
        return _promise;
    }
    wrapper.reset = async () => {
        const _prev = _promise;
        _promise = undefined;
        if (_prev)
            await _prev;
    };
    return wrapper;
}
function invoke(fn) {
    return fn();
}
function containsProp(obj, ...props) {
    return props.some(k => k in obj);
}
function increaseWithUnit(target, delta) {
    var _a;
    if (typeof target === 'number')
        return target + delta;
    const value = ((_a = target.match(/^-?[0-9]+\.?[0-9]*/)) === null || _a === void 0 ? void 0 : _a[0]) || '';
    const unit = target.slice(value.length);
    const result = (parseFloat(value) + delta);
    if (Number.isNaN(result))
        return target;
    return result + unit;
}
/**
 * Create a new subset object by giving keys
 *
 * @category Object
 */
function objectPick(obj, keys, omitUndefined = false) {
    return keys.reduce((n, k) => {
        if (k in obj)
            if (!omitUndefined || !obj[k] === undefined)
                n[k] = obj[k];
        return n;
    }, {});
}

// implementation
function watchWithFilter(source, cb, options = {}) {
    const { eventFilter = bypassFilter } = options, watchOptions = __rest(options, ["eventFilter"]);
    return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}

// implementation
function debouncedWatch(source, cb, options = {}) {
    const { debounce = 0 } = options, watchOptions = __rest(options, ["debounce"]);
    return watchWithFilter(source, cb, Object.assign(Object.assign({}, watchOptions), { eventFilter: debounceFilter(debounce) }));
}

// ported from https://dev.to/linusborg/vue-when-a-computed-property-can-be-the-wrong-tool-195j
function eagerComputed(fn) {
    const result = shallowRef();
    watchSyncEffect(() => {
        result.value = fn();
    });
    return readonly(result);
}

function get(obj, key) {
    if (key == null)
        return unref(obj);
    return unref(obj)[key];
}

function ignorableWatch(source, cb, options = {}) {
    const { eventFilter = bypassFilter } = options, watchOptions = __rest(options, ["eventFilter"]);
    const filteredCb = createFilterWrapper(eventFilter, cb);
    let ignoreUpdates;
    let ignorePrevAsyncUpdates;
    let stop;
    if (watchOptions.flush === 'sync') {
        const ignore = ref(false);
        // no op for flush: sync
        ignorePrevAsyncUpdates = () => { };
        ignoreUpdates = (updater) => {
            // Call the updater function and count how many sync updates are performed,
            // then add them to the ignore count
            ignore.value = true;
            updater();
            ignore.value = false;
        };
        stop = watch(source, (...args) => {
            if (!ignore.value)
                filteredCb(...args);
        }, watchOptions);
    }
    else {
        // flush 'pre' and 'post'
        const disposables = [];
        // counters for how many following changes to be ignored
        // ignoreCounter is incremented before there is a history operation
        // affecting the source ref value (undo, redo, revert).
        // syncCounter is incremented in sync with every change to the
        // source ref value. This let us know how many times the ref
        // was modified and support chained sync operations. If there
        // are more sync triggers than the ignore count, the we now
        // there are modifications in the source ref value that we
        // need to commit
        const ignoreCounter = ref(0);
        const syncCounter = ref(0);
        ignorePrevAsyncUpdates = () => {
            ignoreCounter.value = syncCounter.value;
        };
        // Sync watch to count modifications to the source
        disposables.push(watch(source, () => {
            syncCounter.value++;
        }, Object.assign(Object.assign({}, watchOptions), { flush: 'sync' })));
        ignoreUpdates = (updater) => {
            // Call the updater function and count how many sync updates are performed,
            // then add them to the ignore count
            const syncCounterPrev = syncCounter.value;
            updater();
            ignoreCounter.value += syncCounter.value - syncCounterPrev;
        };
        disposables.push(watch(source, (...args) => {
            // If a history operation was performed (ignoreCounter > 0) and there are
            // no other changes to the source ref value afterwards, then ignore this commit
            const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
            ignoreCounter.value = 0;
            syncCounter.value = 0;
            if (ignore)
                return;
            filteredCb(...args);
        }, watchOptions));
        stop = () => {
            disposables.forEach(fn => fn());
        };
    }
    return { stop, ignoreUpdates, ignorePrevAsyncUpdates };
}

function makeDestructurable(obj, arr) {
    if (typeof Symbol !== 'undefined') {
        const clone = Object.assign({}, obj);
        Object.defineProperty(clone, Symbol.iterator, {
            enumerable: false,
            value() {
                let index = 0;
                return {
                    next: () => ({
                        value: arr[index++],
                        done: index > arr.length,
                    }),
                };
            },
        });
        return clone;
    }
    else {
        return Object.assign([...arr], obj);
    }
}

/**
 * `NOT` conditions for refs.
 *
 * @see https://vueuse.org/not
 */
function not(v) {
    return computed(() => !unref(v));
}

/**
 * `OR` conditions for refs.
 *
 * @see https://vueuse.org/or
 */
function or(...args) {
    return computed(() => args.some(i => unref(i)));
}

// implementation
function pausableWatch(source, cb, options = {}) {
    const { eventFilter: filter } = options, watchOptions = __rest(options, ["eventFilter"]);
    const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
    const stop = watchWithFilter(source, cb, Object.assign(Object.assign({}, watchOptions), { eventFilter }));
    return { stop, pause, resume, isActive };
}

/**
 * Converts plain function into a reactive function.
 * The converted function accepts refs as it's arguments
 * and returns a ComputedRef, with proper typing.
 *
 * @param fn - Source function
 */
function reactify(fn) {
    return function (...args) {
        return computed(() => fn.apply(this, args.map(i => unref(i))));
    };
}

function reactifyObject(obj, optionsOrKeys = {}) {
    let keys = [];
    if (Array.isArray(optionsOrKeys)) {
        keys = optionsOrKeys;
    }
    else {
        const { includeOwnProperties = true } = optionsOrKeys;
        keys.push(...Object.keys(obj));
        if (includeOwnProperties)
            keys.push(...Object.getOwnPropertyNames(obj));
    }
    return Object.fromEntries(keys
        .map((key) => {
        const value = obj[key];
        return [
            key,
            typeof value === 'function'
                ? reactify(value.bind(obj))
                : value,
        ];
    }));
}

/**
 * Reactively pick fields from a reactive object
 *
 * @see https://vueuse.js.org/reactivePick
 */
function reactivePick(obj, ...keys) {
    return reactive(Object.fromEntries(keys.map(k => [k, toRef(obj, k)])));
}

/**
 *  Shorthand for `ref.value = x`
 */
function set(...args) {
    if (args.length === 2) {
        const [ref, value] = args;
        ref.value = value;
    }
    if (args.length === 3) {
        if (isVue2) {
            // use @vue/composition-api's set API
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            require('vue-demi').set(...args);
        }
        else {
            const [target, key, value] = args;
            target[key] = value;
        }
    }
}

/**
 * Keep target ref(s) in sync with the source ref
 *
 * @param source source ref
 * @param targets
 */
function syncRef(source, targets, { flush = 'sync', deep = false, immediate = true, } = {}) {
    if (!Array.isArray(targets))
        targets = [targets];
    return watch(source, (newValue) => {
        targets.forEach(target => target.value = newValue);
    }, {
        flush,
        deep,
        immediate,
    });
}

// implementation
function throttledWatch(source, cb, options = {}) {
    const { throttle = 0, trailing = true } = options, watchOptions = __rest(options, ["throttle", "trailing"]);
    return watchWithFilter(source, cb, Object.assign(Object.assign({}, watchOptions), { eventFilter: throttleFilter(throttle, trailing) }));
}

/**
 * Converts ref to reactive.
 *
 * @see https://vueuse.org/toReactive
 * @param objectRef A ref of object
 */
function toReactive(objectRef) {
    if (!isRef(objectRef))
        return reactive(objectRef);
    const proxy = new Proxy({}, {
        get(_, p, receiver) {
            return Reflect.get(objectRef.value, p, receiver);
        },
        set(_, p, value) {
            objectRef.value[p] = value;
            return true;
        },
        deleteProperty(_, p) {
            return Reflect.deleteProperty(objectRef.value, p);
        },
        has(_, p) {
            return Reflect.has(objectRef.value, p);
        },
        ownKeys() {
            return Object.keys(objectRef.value);
        },
        getOwnPropertyDescriptor() {
            return {
                enumerable: true,
                configurable: true,
            };
        },
    });
    return reactive(proxy);
}

/**
 * Extended `toRefs` that also accepts refs of an object.
 *
 * @see https://vueuse.org/toRefs
 * @param objectRef A ref or normal object or array.
 */
function toRefs(objectRef) {
    if (!isRef(objectRef))
        return toRefs$1(objectRef);
    const result = Array.isArray(objectRef.value)
        ? new Array(objectRef.value.length)
        : {};
    // eslint-disable-next-line no-restricted-syntax
    for (const key in objectRef.value) {
        result[key] = customRef(() => ({
            get() {
                return objectRef.value[key];
            },
            set(v) {
                objectRef.value[key] = v;
            },
        }));
    }
    return result;
}

/**
 * Call onBeforeUnmount() if it's inside a component lifecycle, if not, do nothing
 *
 * @param fn
 */
function tryOnBeforeUnmount(fn) {
    if (getCurrentInstance())
        onBeforeUnmount(fn);
}

/**
 * Call onMounted() if it's inside a component lifecycle, if not, run just call the function
 *
 * @param fn
 * @param sync if set to false, it will run in the nextTick() of Vue
 */
function tryOnMounted(fn, sync = true) {
    if (getCurrentInstance())
        onMounted(fn);
    else if (sync)
        fn();
    else
        nextTick(fn);
}

/**
 * Call onUnmounted() if it's inside a component lifecycle, if not, do nothing
 *
 * @param fn
 */
function tryOnUnmounted(fn) {
    if (getCurrentInstance())
        onUnmounted(fn);
}

function until(r) {
    let isNot = false;
    function toMatch(condition, { flush = 'sync', deep = false, timeout, throwOnTimeout } = {}) {
        let stop = null;
        const watcher = new Promise((resolve) => {
            stop = watch(r, (v) => {
                if (condition(v) === !isNot) {
                    stop === null || stop === void 0 ? void 0 : stop();
                    resolve();
                }
            }, {
                flush,
                deep,
                immediate: true,
            });
        });
        const promises = [watcher];
        if (timeout) {
            promises.push(promiseTimeout(timeout, throwOnTimeout).finally(() => {
                stop === null || stop === void 0 ? void 0 : stop();
            }));
        }
        return Promise.race(promises);
    }
    function toBe(value, options) {
        return toMatch(v => v === unref(value), options);
    }
    function toBeTruthy(options) {
        return toMatch(v => Boolean(v), options);
    }
    function toBeNull(options) {
        return toBe(null, options);
    }
    function toBeUndefined(options) {
        return toBe(undefined, options);
    }
    function toBeNaN(options) {
        return toMatch(Number.isNaN, options);
    }
    function toContains(value, options) {
        return toMatch((v) => {
            const array = Array.from(v);
            return array.includes(value) || array.includes(unref(value));
        }, options);
    }
    function changed(options) {
        return changedTimes(1, options);
    }
    function changedTimes(n = 1, options) {
        let count = -1; // skip the immediate check
        return toMatch(() => {
            count += 1;
            return count >= n;
        }, options);
    }
    if (Array.isArray(unref(r))) {
        const instance = {
            toMatch,
            toContains,
            changed,
            changedTimes,
            get not() {
                isNot = !isNot;
                return this;
            },
        };
        return instance;
    }
    else {
        const instance = {
            toMatch,
            toBe,
            toBeTruthy,
            toBeNull,
            toBeNaN,
            toBeUndefined,
            changed,
            changedTimes,
            get not() {
                isNot = !isNot;
                return this;
            },
        };
        return instance;
    }
}

/**
 * Basic counter with utility functions.
 *
 * @see https://vueuse.org/useCounter
 * @param [initialValue=0]
 */
function useCounter(initialValue = 0) {
    const count = ref(initialValue);
    const inc = (delta = 1) => (count.value += delta);
    const dec = (delta = 1) => (count.value -= delta);
    const get = () => count.value;
    const set = (val) => (count.value = val);
    const reset = (val = initialValue) => {
        initialValue = val;
        return set(val);
    };
    return { count, inc, dec, get, set, reset };
}

/**
 * Debounce execution of a function.
 *
 * @param  fn          A function to be executed after delay milliseconds debounced.
 * @param  ms          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 *
 * @return A new, debounce, function.
 */
function useDebounceFn(fn, ms = 200) {
    return createFilterWrapper(debounceFilter(ms), fn);
}

function useDebounce(value, ms = 200) {
    if (ms <= 0)
        return value;
    const debounced = ref(value.value);
    const updater = useDebounceFn(() => {
        debounced.value = value.value;
    }, ms);
    watch(value, () => updater());
    return debounced;
}

/**
 * Wrapper for `setInterval` with controls
 *
 * @param cb
 * @param interval
 * @param options
 */
function useIntervalFn(cb, interval = 1000, options = {}) {
    const { immediate = true, immediateCallback = false, } = options;
    let timer = null;
    const isActive = ref(false);
    function clean() {
        if (timer) {
            clearInterval(timer);
            timer = null;
        }
    }
    function pause() {
        isActive.value = false;
        clean();
    }
    function resume() {
        if (interval <= 0)
            return;
        isActive.value = true;
        if (immediateCallback)
            cb();
        clean();
        timer = setInterval(cb, interval);
    }
    if (immediate && isClient)
        resume();
    tryOnScopeDispose(pause);
    return {
        isActive,
        pause,
        resume,
    };
}

function useInterval(interval = 1000, options = {}) {
    const { controls: exposeControls = false, immediate = true, } = options;
    const counter = ref(0);
    const controls = useIntervalFn(() => counter.value += 1, interval, { immediate });
    if (exposeControls) {
        return Object.assign({ counter }, controls);
    }
    else {
        return counter;
    }
}

function useLastChanged(source, options = {}) {
    var _a;
    const ms = ref((_a = options.initialValue) !== null && _a !== void 0 ? _a : null);
    watch(source, () => ms.value = timestamp(), options);
    return ms;
}

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param   fn             A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param   ms             A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 *
 * @param [trailing=true] if true, call fn again after the time is up
 *
 * @return  A new, throttled, function.
 */
function useThrottleFn(fn, ms = 200, trailing = true) {
    return createFilterWrapper(throttleFilter(ms, trailing), fn);
}

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param value Ref value to be watched with throttle effect
 * @param  delay  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param [trailing=true] if true, update the value again after the delay time is up
 */
function useThrottle(value, delay = 200, trailing = true) {
    if (delay <= 0)
        return value;
    const throttled = ref(value.value);
    const updater = useThrottleFn(() => {
        throttled.value = value.value;
    }, delay, trailing);
    watch(value, () => updater());
    return throttled;
}

/**
 * Wrapper for `setTimeout` with controls.
 *
 * @param cb
 * @param interval
 * @param immediate
 */
function useTimeoutFn(cb, interval, options = {}) {
    const { immediate = true, } = options;
    const isPending = ref(false);
    let timer = null;
    function clear() {
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
    }
    function stop() {
        isPending.value = false;
        clear();
    }
    function start(...args) {
        clear();
        isPending.value = true;
        timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            // eslint-disable-next-line node/no-callback-literal
            cb(...args);
        }, unref(interval));
    }
    if (immediate) {
        isPending.value = true;
        if (isClient)
            start();
    }
    tryOnScopeDispose(stop);
    return {
        isPending,
        start,
        stop,
    };
}

function useTimeout(interval = 1000, options = {}) {
    const { controls: exposeControls = false, } = options;
    const controls = useTimeoutFn(noop, interval, options);
    const ready = computed(() => !controls.isPending.value);
    if (exposeControls) {
        return Object.assign({ ready }, controls);
    }
    else {
        return ready;
    }
}

function useToggle(initialValue = false) {
    if (isRef(initialValue)) {
        return (value) => {
            initialValue.value = typeof value === 'boolean'
                ? value
                : !initialValue.value;
        };
    }
    else {
        const boolean = ref(initialValue);
        const toggle = (value) => {
            boolean.value = typeof value === 'boolean'
                ? value
                : !boolean.value;
        };
        return [boolean, toggle];
    }
}

// implementation
function watchAtMost(source, cb, options) {
    const { count } = options, watchOptions = __rest(options, ["count"]);
    const current = ref(0);
    const stop = watchWithFilter(source, (...args) => {
        current.value += 1;
        if (current.value >= unref(count))
            stop();
        cb(...args);
    }, watchOptions);
    return { count: current, stop };
}

/**
 * Shorthand for watching value to be truthy
 *
 * @see https://vueuse.js.org/whenever
 */
function whenever(source, cb, options) {
    return watch(source, (v, ov, onInvalidate) => { if (v)
        cb(v, ov, onInvalidate); }, options);
}

export { and, assert, biSyncRef, bypassFilter, clamp, containsProp, controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createSharedComposable, createSingletonPromise, debounceFilter, debouncedWatch, eagerComputed, extendRef, get, identity, ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isFunction, isNumber, isObject, isString, isWindow, makeDestructurable, noop, not, now, objectPick, or, pausableFilter, pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactivePick, set, syncRef, throttleFilter, throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useCounter, useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToggle, watchAtMost, watchWithFilter, whenever };
