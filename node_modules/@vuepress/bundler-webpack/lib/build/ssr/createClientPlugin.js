"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClientPlugin = void 0;
const utils_1 = require("@vuepress/utils");
const utils_2 = require("./utils");
/**
 * Vuepress client plugin
 *
 * Collecting webpack bundled files info for SSR
 */
const createClientPlugin = (outputFile) => {
    const clientPlugin = {
        apply(compiler) {
            compiler.hooks.emit.tapPromise('vuepress-client-plugin', async (compilation) => {
                // get webpack stats object
                const stats = compilation
                    .getStats()
                    .toJson();
                const { assets = [], modules = [], entrypoints = {}, chunks = [], } = stats;
                // get all files
                const allFiles = assets.map((a) => a.name);
                // get initial entry files
                const initialFiles = Object.keys(entrypoints)
                    .map((name) => entrypoints[name].assets.map((item) => item.name))
                    .reduce((assets, all) => all.concat(assets), [])
                    .filter((file) => utils_2.isJS(file) || utils_2.isCSS(file));
                // get files that should be loaded asynchronously
                // i.e. script and style files that are not included in the initial entry files
                const asyncFiles = allFiles.filter((file) => (utils_2.isJS(file) || utils_2.isCSS(file)) && !initialFiles.includes(file));
                // get asset modules
                const assetModules = modules.filter((m) => !!(m.assets && m.assets.length));
                // get modules for client manifest
                const manifestModules = {};
                const fileToIndex = (file) => allFiles.indexOf(file);
                modules.forEach((m) => {
                    // ignore modules duplicated in multiple chunks
                    if (m.chunks.length !== 1) {
                        return;
                    }
                    const cid = m.chunks[0];
                    const chunk = chunks.find((c) => c.id === cid);
                    if (!chunk || !chunk.files) {
                        return;
                    }
                    // remove appended hash of module identifier
                    // which is the request string of the module
                    const request = m.identifier.replace(/\s\w+$/, '');
                    // get chunk files index
                    const files = [...chunk.files.map(fileToIndex)];
                    // find all asset modules associated with the same chunk
                    assetModules.forEach((m) => {
                        if (m.chunks.some((id) => id === cid)) {
                            // get asset files
                            files.push(...m.assets.map(fileToIndex));
                        }
                    });
                    // map the module request to files index
                    manifestModules[request] = files;
                });
                // generate client manifest json file
                const clientManifest = {
                    all: allFiles,
                    initial: initialFiles,
                    async: asyncFiles,
                    modules: manifestModules,
                };
                const clientManifestJson = JSON.stringify(clientManifest, null, 2);
                await utils_1.fs.outputFile(outputFile, clientManifestJson);
            });
        },
    };
    return clientPlugin;
};
exports.createClientPlugin = createClientPlugin;
